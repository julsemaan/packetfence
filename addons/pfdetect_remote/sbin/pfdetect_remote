#!/usr/bin/perl

=head1 NAME

pfdetect-remote - listen to violations alerts and send them to PF server

=head1 SYNOPSIS

pfdetect -p <file | named pipe> -e <ENGINE>  [options]

  Options:
    -d  Daemonize
    -h  Help

  ENGINE is one of : snort, tippingp or trend

=cut

use Getopt::Std;
use File::Basename;
use FileHandle;
use POSIX qw(:signal_h);
use SOAP::Lite;
use Sys::Syslog;
use Config::IniFiles;
use Data::Dumper;
use Pod::Usage;
use strict;
use warnings;


POSIX::sigaction(
    &POSIX::SIGHUP,
    POSIX::SigAction->new(
        'restart_handler', POSIX::SigSet->new(), &POSIX::SA_NODEFER
    )
) or die "pfdetect_remote: could not set SIGHUP handler: $!\n";

POSIX::sigaction(
    &POSIX::SIGTERM,
    POSIX::SigAction->new(
        'normal_sighandler', POSIX::SigSet->new(), &POSIX::SA_NODEFER
    )
) or die "pfdetect_remote: could not set SIGTERM handler: $!\n";

POSIX::sigaction(
    &POSIX::SIGINT,
    POSIX::SigAction->new(
        'normal_sighandler', POSIX::SigSet->new(), &POSIX::SA_NODEFER
    )
) or die "pfdetect_remote: could not set SIGINT handler: $!\n";


my @ORIG_ARGV = @ARGV;
my %args;
getopts( 'c:dhvp:i:', \%args );

pod2usage( -verbose => 1 ) if ( $args{h} or !$args{p} or !$args{i} );

my $daemonize = $args{d};
my $input     = $args{p};    # input can be from either a logfile or a pipe

#Prevent error from LWP : ensure it connects to servers that have a valid certificate matching the expected hostname
$ENV{PERL_LWP_SSL_VERIFY_HOSTNAME}=0;

my $IDS       = $args{i};    # one of snort, tippingp, trend etc.
my $script    = File::Basename::basename($0);

my $install_dir = defined $args{c} ? $args{c} : '/usr/local/pf';

daemonize() if ($daemonize);


my $install_dir = defined $args{c} ? 
                  $args{c} : 
                  '/usr/local/pf';
my $cfg         = new Config::IniFiles( -file => "$install_dir/conf/pfdetect_remote.conf" );
my $daemonize   = $args{d};
my $ADMIN_USER  = $cfg->val( 'server', 'user' );
my $ADMIN_PWD   = $cfg->val( 'server', 'password' );
my $PF_HOST     = $cfg->val( 'server', 'host' );
my $ENGINE      = defined $args{e} ?
                  $args{e} :
                  $cfg->val( 'trapping', 'detection_engine' );
my $SOURCE      = defined $args{p} ? 
                  $args{p} : 
                  $cfg->val( 'trapping', 'alert_source' );   # input can be from either a logfile or a pipe
my $script      = File::Basename::basename($0);
my $log_level   = defined $cfg->val( 'logging', 'level') ?
                  trim( $cfg->val( 'logging', 'level') ):
                  "info";
my $log_facility = defined $cfg->val( 'logging', 'facility') ?
                  trim( $cfg->val( 'logging', 'facility') ):
                  "auth";

openlog( "pfdetect_remote", '', $log_facility );
syslog( $log_level, "initialized" );

if (defined $cfg->val( 'server', 'insecure')) {
    syslog( $log_level, "Insecure mode: ignoring SSL certs errors");
    $ENV{PERL_LWP_SSL_VERIFY_HOSTNAME}=0; 
}

daemonize() if ($daemonize);

my $fh = new File::Tail(
    'name'        => $SOURCE,
    'interval'    => 2,
    'reset_tail'  => 0,
    'maxinterval' => 2
);
syslog( "info", "listening on $SOURCE" );

<<<<<<< HEAD
# A dispatch table where the key is the type of event to parse 
=======
# A dispatch table where the key is the type of event to parse
>>>>>>> Added bare-bones trend parsing sub.
# and the value is a ref to the appropriate sub for the type.
my $parse_alert_for = {
    snort    => \&parse_snort_alert,
    tippingp => \&parse_tippingp_alert,
    trend    => \&parse_trend_alert,
    fortigate    => \&parse_fortigate_alert,
};

my $currentLine;
READALERT:
while ( defined( $currentLine = $fh->read ) ) {

    syslog( "info", "alert received: $currentLine" );

    my %event = $parse_alert_for->{$ENGINE}->($currentLine);
    if ( !defined( $event{"event_id"} ) or 
         !defined( $event{"date"}     ) or
         !defined( $event{"srcip"}    ) ) {
        syslog( "warning", "unparsed input: $currentLine " );
        next READALERT;
    }

    eval {
        my $soap = new SOAP::Lite(
            uri   => 'http://www.packetfence.org/PFAPI',
            proxy => 'https://'
              . $ADMIN_USER . ':'
              . $ADMIN_PWD . '@'
              . $PF_HOST
              . '/webapi'
        );
        my $result =
          $soap->event_add( $event{"date"}, $event{"srcip"}, "detect", $event{"event_id"} );
        if ( $result->fault ) {
            syslog( "warning",
                    "violation could not be added: "
                  . $result->faultcode . " - "
                  . $result->faultstring . " - "
                  . $result->faultdetail );
        }
        else {
            syslog( "info",
                qq(added violation $event{"event_id"} for $event{"srcip"}) );
        }
    };
    if ($@) {
        syslog( "warning", "connection to $PF_HOST with username $ADMIN_USER was NOT successful: $@");
        next READALERT;
    }

}

END {
    deletepid();
    syslog( "info", "stopping pfdetect_remote" );
}

exit(0);

=pod

=head1 Subroutines:

=cut 

sub daemonize {
    chdir '/' or die "Can't chdir to /: $!";
    open STDIN,  '<', '/dev/null' or die "Can't read /dev/null: $!";
    open STDOUT, '>', '/dev/null' or die "Can't write to /dev/null: $!";

    defined( my $pid = fork ) or die "pfdetect_remote: could not fork: $!";
    POSIX::_exit(0) if ($pid);
    if ( !POSIX::setsid() ) {
        syslog( "warning", "could not start a new session: $!" );
    }
    open STDERR, '>&STDOUT' or die "Can't dup stdout: $!";
    createpid();
    return 1;
}

sub normal_sighandler {
    deletepid();
    syslog( "info", "caught SIG" . $_[0] . " - terminating pfdetect_remote" );
    die( "pfdetect_remote: caught SIG" . $_[0] . " - terminating\n" );
}

sub restart_handler {
    deletepid();
    syslog( "info", "caught SIG" . $_[0] . " - restarting pfdetect_remote" );
    if ( !exec( $0, @ORIG_ARGV ) ) {
        syslog( "warning", "could not restart: #!" );
        die "pfdetect_remote: could not restart: $!\n";
    }
}

sub createpid {
    my $pname   = basename($0);
    my $pid     = $$;
    my $pidfile = $install_dir . "/var/$pname.pid";
    syslog( "info", "$pname starting and writing $pid to $pidfile" );
    my $outfile = new FileHandle ">$pidfile";
    if ( defined($outfile) ) {
        print $outfile $pid;
        $outfile->close;
        return ($pid);
    }
    else {
        syslog( "warning", "$pname: unable to open $pidfile for writing: $!" );
        return (-1);
    }
}

sub deletepid {
    my ($pname) = @_;
    $pname = basename($0) if ( !$pname );
    my $pidfile = $install_dir . "/var/$pname.pid";
    unlink($pidfile) || return (-1);
    return (1);
}

# we sometimes need to trim the end of configuration values
sub trim {
    my $string = shift;
    $string =~ s/^\s+//;
    $string =~ s/\s+$//;
    return $string;
}

=pod

=head2 parse_snort_alert 
This sub will parse a line from a snort event and fill in the %event hash;

=cut 

sub parse_snort_alert {
    my $currentLine  = shift;
    my $portscan_sid = 1200003;    # portscan is a special case
    my %event;

    my $syslog_prefix = qr/              # used when reading from syslog
        ( \S{2,3} \s+ \S+ \s \S+ ) \s+   # $1 is MM DD HH:MM:SS
        [\w.]+ \s snort\[ \d+ \] : \s+   # typically something like "`hostname` snort[pid]:"
    /x;

    my $fifo_prefix = qr/                # used when reading from snort fifo
        (\S+)  \s+                       # $1 is the date
        \[\*\*\] \s+                     # a litteral [**]
    /x;

    # a regex that matches any snort alert.
    my $snort_line = qr/
        ^
        (?: $syslog_prefix | $fifo_prefix )             # $1 matches the date based on the input type
        \[\d+: (\d+): \d+\] \s+                         # $2 is snort id :  [ gid : $2 : rev ] 
        ( .+ ) $                                        # $3 is description, src and dst ips
    /x;

    # most snort alerts match this (except for portscans)
    my $snort_details = qr/
        ^
        .+?
        (\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}) (?: :\d+)? \s+         # $1 is src ip (with optional :port)
        \-\>   \s+                                                  # ->
        (\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}) (?: :\d+)?             # $2 is dst ip (with optional :port)
    /x;

    # snort portscans match this one.
    my $portscan = qr/
        Portscan\s+detected\s+from\s+                   
        (\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})            # $1 is the $srcip
    /x;

    # we match the part of the snort line that is common to all snort alert and
    # keep the remainder for the second step.
    my ( $syslog_date, $fifo_date, $event_id, $remainder ) = $currentLine =~  /$snort_line/;

    # date will be defined either in syslog_date or fifo_date depending on input type.
    $event{"date"} = defined $syslog_date ? $syslog_date : $fifo_date;
    $event{"event_id"} = $event_id;

    # then we match again on the remainder, trying in turn every type of alert.
    if ( ( my $srcip ) = $remainder =~ $portscan ) {
        @event{qw( srcip event_id )} = ( $srcip, $portscan_sid );
    }
    elsif ( @event{qw( srcip dstip )} = $remainder =~ $snort_details ) {
    }
    else {
        $event{"event_id"} = "unknown";
    }

    return %event;
}

=pod

=head2 parse_tippingp_alert 
This sub will parse a line from a Tipping Point event and fill in the %event hash;

=cut 

sub parse_tippingp_alert {
    my $currentLine = shift;
    my %event;

    my $tippingp_alert = qr/
        ^(.+?)\s+                               # $1 is date
        \b \d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}   # an ip 
        \sALT\;v\d\;                            # ALT;v${VERSION};
    /x;

    ( $event{"date"} ) = $currentLine =~ $tippingp_alert;
    my @hpValues = split( ';', $currentLine );

    ( @event{qw(event_id  descr)} ) = $hpValues[10] =~ /(\d+)\:\s(.*)\"$/;
    @event{qw( srcip dstip )} = @hpValues[ 13, 15 ];

    return %event;
}

=pod

=head2 parse_trend_alert 
This sub will parse a line from a Trend Micro event and fill in the %event hash;

=cut 

sub parse_trend_alert {
    chomp( my $currentLine = shift );
    my %event;

    my $trend_date = qr/
        ^ 
        (\w+ \s+            # Month
        \d+ \s+             # Day
        \d+:\d+:\d+) \s     # HH:MM:SS  $1 is the whole date
    /x;

    my $trend_srcip = qr/
        \s+ malSrcIp= 
        ( \d+\.\d+\.\d+\.\d+ ) \s   # $1 is an IP 
    /x;

    # trend alert is pipe separated
    my @fields = ( split( /\|/, $currentLine ) )[ 0, 4, 7 ];  # we ignore irrelevant fields
    ( $event{"date"} )  = ( $fields[0] =~ $trend_date ); 
    $event{"event_id"}  = $fields[1];
    ( $event{"srcip"} ) = ($fields[2] =~ $trend_srcip) ;

    return %event;
}

=pod

=head2 parse_fortigate_alert 
This sub will parse a line from a Fortigate event and fill in the %event hash;

Example :
Mar  3 18:48:58 172.21.2.63 date=2014-03-03 time=18:49:15 devname=FortiGate-VM64 devid=FGVM010000016588 logid=0316013057 type=utm subtype=webfilter eventtype=ftgd_blk level=warning vd="root" policyid=1 identidx=0 sessionid=45421 osname="Windows" osversion="7 (x64)" srcip=172.21.5.11 srcport=2019 srcintf="port2" dstip=64.210.140.16 dstport=80 dstintf="port1" service="http" hostname="www.porn.com" profiletype="Webfilter_Profile" profile="default" status="blocked" reqtype="referral" url="/videos/brunette-sucks-and-fucks-stranger-in-the-steam-room-1439589.html" sentbyte=820 rcvdbyte=1448 msg="URL belongs to a category with warnings enabled" method=domain class=0 cat=14 catdesc="Pornography"

=cut 

sub parse_fortigate_alert {
    chomp( my $currentLine = shift );
	my %event;

    my @fields = grep  /\=/ ,  split( /\s+/, $currentLine );
    my %fields = map { split /\=/ } @fields;
    $event{"date"} = $fields{date};
    $event{"srcip"} = $fields{srcip};
    $event{"catid"} = $fields{cat};

    return %event;
}

=head1 AUTHOR

Inverse inc. <info@inverse.ca>

Louis Munro  <lmunro@inverse.ca>

=head1 COPYRIGHT

Copyright (C) 2005-2013 Inverse inc.

=head1 LICENSE

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
USA.

=cut

# vim: set shiftwidth=4:
# vim: set expandtab:
# vim: set backspace=indent,eol,start:
