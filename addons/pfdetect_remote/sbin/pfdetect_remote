#!/usr/bin/perl

=head1 NAME

pfdetect-remote - listen to violations alerts and send them to PF server

=head1 SYNOPSIS

pfdetect -p <file | named pipe> -i <IDS>  [options]

  Options:
    -d  Daemonize
    -h  Help

  IDS is one of : snort, tippingp or trend

=cut

use Getopt::Std;
use File::Basename;
use FileHandle;
use POSIX qw(:signal_h);
use SOAP::Lite;
use Sys::Syslog;
use Config::IniFiles;
use Data::Dumper;
use Pod::Usage;
use strict;
use warnings;

POSIX::sigaction(
    &POSIX::SIGHUP,
    POSIX::SigAction->new(
        'restart_handler', POSIX::SigSet->new(), &POSIX::SA_NODEFER
    )
) or die "pfdetect_remote: could not set SIGHUP handler: $!\n";

POSIX::sigaction(
    &POSIX::SIGTERM,
    POSIX::SigAction->new(
        'normal_sighandler', POSIX::SigSet->new(), &POSIX::SA_NODEFER
    )
) or die "pfdetect_remote: could not set SIGTERM handler: $!\n";

POSIX::sigaction(
    &POSIX::SIGINT,
    POSIX::SigAction->new(
        'normal_sighandler', POSIX::SigSet->new(), &POSIX::SA_NODEFER
    )
) or die "pfdetect_remote: could not set SIGINT handler: $!\n";


my @ORIG_ARGV = @ARGV;
my %args;
getopts( 'c:dhvp:i:', \%args );

pod2usage( -verbose => 1 ) if ( $args{h} or !$args{p} or !$args{i} );

my $daemonize = $args{d};
my $input     = $args{p};    # input can be from either a logfile or a pipe

#Prevent error from LWP : ensure it connects to servers that have a valid certificate matching the expected hostname
$ENV{PERL_LWP_SSL_VERIFY_HOSTNAME}=0;

my $IDS       = $args{i};    # one of snort, tippingp, trend etc.
my $script    = File::Basename::basename($0);

my $install_dir = defined $args{c} ? $args{c} : '/usr/local/pf';

daemonize() if ($daemonize);

openlog( "pfdetect_remote", '', 'auth' );
syslog( "info", "initialized" );

my $cfg =
  new Config::IniFiles( -file => "$install_dir/conf/pfdetect_remote.conf" );
my $ADMIN_USER = $cfg->val( 'server', 'user' );
my $ADMIN_PWD  = $cfg->val( 'server', 'password' );
my $PF_HOST    = $cfg->val( 'server', 'host' );

my $fh = new File::Tail(
    'name'        => $input,
    'interval'    => 2,
    'reset_tail'  => 0,
    'maxinterval' => 2
);
syslog( "info", "listening on $input" );

<<<<<<< HEAD
# A dispatch table where the key is the type of event to parse 
=======
# A dispatch table where the key is the type of event to parse
>>>>>>> Added bare-bones trend parsing sub.
# and the value is a ref to the appropriate sub for the type.
my $parse_alert_for = {
    snort    => \&parse_snort_alert,
    tippingp => \&parse_tippingp_alert,
    trend    => \&parse_trend_alert,
};

my $currentLine;
while ( defined( $currentLine = $fh->read ) ) {

    syslog( "info", "alert received: $currentLine" );

    my %event;
    %event = $parse_alert_for->{$IDS}->($currentLine);
    if ( !defined( $event{"event_id"} ) or $event{"event_id"} eq "unknown" ) {
        syslog( "warning", "unknown input: $currentLine " );
    }

    eval {
        my $soap = new SOAP::Lite(
            uri   => 'http://www.packetfence.org/PFAPI',
            proxy => 'https://'
              . $ADMIN_USER . ':'
              . $ADMIN_PWD . '@'
              . $PF_HOST
              . '/webapi'
        );
        my $result =
          $soap->event_add( $event{"date"}, $event{"srcip"}, "detect",
            $event{"event_id"} );
        if ( $result->fault ) {
            syslog( "warning",
                    "violation could not be added: "
                  . $result->faultcode . " - "
                  . $result->faultstring . " - "
                  . $result->faultdetail );
        }
        else {
            syslog( "info",
                qq(added violation $event{"event_id"} for $event{"srcip"}) );
        }
    };
    if ($@) {
        syslog( "warning", "connection to $PF_HOST with username $ADMIN_USER was NOT successful: $@"
        );
        next;
    }

}

END {
    deletepid();
    syslog( "info", "stopping pfdetect_remote" );
}

exit(0);

=pod

=head1 Subroutines:

=cut 

sub daemonize {
    chdir '/' or die "Can't chdir to /: $!";
    open STDIN,  '<', '/dev/null' or die "Can't read /dev/null: $!";
    open STDOUT, '>', '/dev/null' or die "Can't write to /dev/null: $!";

    defined( my $pid = fork ) or die "pfdetect_remote: could not fork: $!";
    POSIX::_exit(0) if ($pid);
    if ( !POSIX::setsid() ) {
        syslog( "warning", "could not start a new session: $!" );
    }
    open STDERR, '>&STDOUT' or die "Can't dup stdout: $!";
    createpid();
    return 1;
}

sub normal_sighandler {
    deletepid();
    syslog( "info", "caught SIG" . $_[0] . " - terminating pfdetect_remote" );
    die( "pfdetect_remote: caught SIG" . $_[0] . " - terminating\n" );
}

sub restart_handler {
    deletepid();
    syslog( "info", "caught SIG" . $_[0] . " - restarting pfdetect_remote" );
    if ( !exec( $0, @ORIG_ARGV ) ) {
        syslog( "warning", "could not restart: #!" );
        die "pfdetect_remote: could not restart: $!\n";
    }
}

sub createpid {
    my $pname   = basename($0);
    my $pid     = $$;
    my $pidfile = $install_dir . "/var/$pname.pid";
    syslog( "info", "$pname starting and writing $pid to $pidfile" );
    my $outfile = new FileHandle ">$pidfile";
    if ( defined($outfile) ) {
        print $outfile $pid;
        $outfile->close;
        return ($pid);
    }
    else {
        syslog( "warning", "$pname: unable to open $pidfile for writing: $!" );
        return (-1);
    }
}

sub deletepid {
    my ($pname) = @_;
    $pname = basename($0) if ( !$pname );
    my $pidfile = $install_dir . "/var/$pname.pid";
    unlink($pidfile) || return (-1);
    return (1);
}

=pod

=head2 parse_snort_alert 
This sub will parse a line from a snort event and fill in the %event hash;

=cut 

sub parse_snort_alert {
    my $currentLine  = shift;
    my $portscan_sid = 1200003;    # portscan is a special case
    my %event;

    # a regex that matches any snort alert.
    my $snort_line = qr/
        ^ 
        (\S+)  \s+                                      # $1 is the date
        \[\*\*\] \s+                                    # a litteral [**]
        \[\d+: (\d+): \d+\] \s+                         # $2 is snort id :  [ gid : $2 : rev ] 
        ( .+ ) $                                        # $3 is description, src and dst ips
    /x;

    # most snort alerts match this (except for portscans)
    my $snort_details = qr/
        ^
        .+?
        (\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}) \s+        # $1 is src ip 
        \-\>   \s+                                      # ->
        (\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})            # $2 is dst ip
    /x;

    # snort portscans match this one.
    my $portscan = qr/
        Portscan\s+detected\s+from\s+                   
        (\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})            # $1 is the $srcip
    /x;

    # we match the part of the snort line that is common to all snort alert and
    # keep the remainder for the second step.
    ( @event{qw( date event_id )}, my $remainder ) =
      $currentLine =~ /$snort_line/;

    # then we match again on the remainder, trying in turn every type of alert.
    if ( ( my $srcip ) = $remainder =~ $portscan ) {
        @event{qw( srcip event_id )} = ( $srcip, $portscan_sid );
    }
    elsif ( @event{qw( srcip dstip )} = $remainder =~ $snort_details ) {
    }
    else {
        syslog( "warning", "unknown input: $currentLine " );
        $event{"event_id"} = "unknown";
    }

    return %event;
}

=pod

=head2 parse_tippingp_alert 
This sub will parse a line from a Tipping Point event and fill in the %event hash;

=cut 

sub parse_tippingp_alert {
    my $currentLine = shift;
    my %event;

    my $tippingp_alert = qr/
        ^(.+?)\s+                               # $1 is date
        \b \d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}   # an ip 
        \sALT\;v\d\;                            # ALT;v${VERSION};
    /x;

    ( $event{"date"} ) = $currentLine =~ $tippingp_alert;
    my @hpValues = split( ';', $currentLine );

    ( @event{qw(event_id  descr)} ) = $hpValues[10] =~ /(\d+)\:\s(.*)\"$/;
    @event{qw( srcip dstip )} = @hpValues[ 13, 15 ];

    return %event;
}

=pod

=head2 parse_trend_alert 
This sub will parse a line from a Trend Micro event and fill in the %event hash;

=cut 

sub parse_trend_alert {
    chomp( my $currentLine = shift );
    my %event;

    my $trend_date = qr/
        ^ 
        (\w+ \s+            # Month
        \d+ \s+             # Day
        \d+:\d+:\d+) \s     # HH:MM:SS  $1 is the whole date
    /x;

    my $trend_srcip = qr/
        ^ 
        \s+ malSrcIp= 
        ( \d+\.\d+\.\d+\.\d+ ) \s   # $1 is an IP 
    /x;

    # trend alert is pipe separated
    my @fields = ( split( /\|/, $currentLine ) )[ 0, 4, 7 ];  # we ignore irrelevant fields
    ( $event{"date"} )  = ( $fields[0] =~ $trend_date ); 
    $event{"event_id"}  = $fields[1];
    ( $event{"srcip"} ) = ($fields[2] =~ $trend_srcip) ;

    return %event;
}

=head1 AUTHOR

Inverse inc. <info@inverse.ca>

Louis Munro  <lmunro@inverse.ca>

=head1 COPYRIGHT

Copyright (C) 2005-2013 Inverse inc.

=head1 LICENSE

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
USA.

=cut

# vim: set shiftwidth=4:
# vim: set expandtab:
# vim: set backspace=indent,eol,start:
