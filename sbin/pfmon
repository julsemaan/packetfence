#!/usr/bin/perl

=head1 NAME

pfmon - ARP listener and maintenance threads

=head1 SYNOPSIS

pfmon [options]

 Options:
   -d      Daemonize
   -h      Help
   -v      Verbose

=cut

use warnings;
use strict;
use Getopt::Std;
use Net::Pcap 0.16;
use File::Basename qw(basename);
use POSIX qw(:signal_h pause :sys_wait_h);
use Pod::Usage;

#pf::log must always be initilized first
BEGIN {
    # log4perl init
    use constant INSTALL_DIR => '/usr/local/pf';
    use lib INSTALL_DIR . "/lib";
    use pf::log(service => 'pfmon');
}

use pf::accounting qw(acct_maintenance);
use pf::config;
use pf::config::cached;
use pf::inline::accounting;
use pf::iplog;
use pf::locationlog;
use pf::node;
use pf::services;
use pf::traplog;
use pf::util;
use pf::services::util;
use pf::violation qw(violation_maintenance);

# initialization
# --------------
# assign process name (see #1464)
our $PROGRAM_NAME = $0 = basename($0);
our @REGISTERED_TASKS;
our $IS_CHILD = 0;
our %CHILDREN;
our @TASKS_RUN;

my $logger = Log::Log4perl->get_logger( $PROGRAM_NAME );

$SIG{HUP} = \&normal_sighandler;
$SIG{INT} = \&normal_sighandler;
$SIG{TERM} = \&normal_sighandler;
$SIG{CHLD} = \&child_sighandler;
$SIG{ALRM} = sub {};

my %args;
getopts( 'dhvr', \%args );

pod2usage( -verbose => 1 ) if ( $args{h} );

my $daemonize = $args{d};
my $verbose   = $args{v};
my $restart   = $args{r};
our $running = 1;

# standard signals and daemonize
daemonize($PROGRAM_NAME) if ($daemonize);

registertasks();
runtasks();
waitforit();
cleanup();

END {
    if ( !$args{h} ) {
        unless($IS_CHILD) {
            deletepid();
            $logger->info("stopping pfmon");
        }
    }
}

exit(0);

=head1 SUBROUTINES

=head2 registertasks

    Register all tasks

=cut

sub registertasks  {
    register_task(
        'iplog cleanup','iplog_cleanup_interval',sub {
            iplog_cleanup( $Config{'expire'}{'iplog'} )
              if ( $Config{'expire'}{'iplog'} );
        }
    );
    register_task(
        'locationlog cleanup','locationlog_cleanup_interval',sub {
            locationlog_cleanup( $Config{'expire'}{'locationlog'} )
              if ( $Config{'expire'}{'locationlog'} );
        }
    );
    register_task(
        'node cleanup','node_cleanup_interval',sub {
            node_cleanup( $Config{'expire'}{'node'} )
              if ( $Config{'expire'}{'node'} );
        }
    );
    register_task(
        'traplog cleanup','traplog_cleanup_interval',sub {
            traplog_cleanup( $Config{'expire'}{'traplog'} )
              if ( $Config{'expire'}{'traplog'} );
        }
    );
    register_task(
        'Expire httpd.admin sessions','httpd_admin_cleanup_interval',sub {
            purge_cache('httpd.admin')
              if ( isenabled($Config{'expire'}{'httpd_admin'}) );
        }
    );
    register_task(
        'Expire httpd.portal sessions','httpd_portal_cleanup_interval',sub {
            purge_cache('httpd.portal')
              if ( isenabled($Config{'expire'}{'httpd_portal'}) );
        }
    );
    register_task(
        'checking registered nodes for expiration','nodes_maintenance_interval',sub {
            nodes_maintenance();
        }
    );
    register_task(
        'checking violations for expiration','violation_maintenance_interval',sub {
            violation_maintenance($Config{maintenance}{violation_maintenance_batch},$Config{maintenance}{violation_maintenance_timeout});
        }
    );
    register_task(
        'checking accounting data for potential bandwidth abuse','inline_accounting_maintenance_interval',sub {
            if (isenabled($Config{'inline'}{'accounting'})) {
                inline_accounting_maintenance($Config{'inline'}{'layer3_accounting_session_timeout'});
            }
        }
    );
    register_task(
        'Account maintenance','acct_maintenance_interval',sub {
            acct_maintenance();
        }
    );
}

sub cleanup {
    while (keys %CHILDREN) {
        kill ( INT => (keys %CHILDREN));
        pause;
    }
}

sub purge_cache {
    my ($namespace) = @_;
    my $cache = pf::CHI->new( namespace => $namespace );
    for my $key ($cache->get_keys) {
        if($cache->exists_and_is_expired($key)) {
            #Add an eval in case of the value deleted before 
            eval {
                $cache->remove($key);
            };
        }
    }
}

sub normal_sighandler {
    $running = 0;
}

sub runtasks {
    while(@REGISTERED_TASKS) {
        my $task = shift @REGISTERED_TASKS;
        runtask($task);
    }
}

sub runtask {
    my ($task) = @_;
    my $pid = fork();
    if($pid) {
        $CHILDREN{$pid} = $task;
    } elsif ($pid == 0) {
        $SIG{CHLD} = "DEFAULT";
        $IS_CHILD = 1;
        _runtask(@$task);
    } else {
    }
}

sub _runtask {
    my ($id,$parameter,$task) = @_;
    while ($running) {
        pf::config::cached::ReloadConfigs();
        my $interval = $Config{'maintenance'}{$parameter};
        unless ($interval) {
            $logger->trace("$id is disabled");
            alarm 60;
            pause;
            next;
        }
        # run these functions every $maintenance_interval
        $logger->trace("$id is sleeping for $interval");
        alarm $interval;
        pause;
        last unless $running;
        $logger->trace("$id is runinng");
        eval {
            #reload all cached configs before running the task
            $task->();
        };
        if ($@) {
            $logger->error("Error running task $id: $@");
        }
    }
    exit;
}

sub register_task {
    my ($taskId, $parameter,$function) = @_;
    push @REGISTERED_TASKS, [ $taskId , $parameter, $function ];

}

sub waitforit {
    while($running) {
        pause;
        runtasks();
    }
}

sub child_sighandler {
    local ($!, $?);
    while(1) {
        my $child = waitpid(-1, WNOHANG);
        last unless $child > 0;
        my $task = delete $CHILDREN{$child};
        register_task(@$task);
    }
}

=head1 AUTHOR

Inverse inc. <info@inverse.ca>

Minor parts of this file may have been contributed. See CREDITS.

=head1 COPYRIGHT

Copyright (C) 2005-2013 Inverse inc.

Copyright (C) 2005 Kevin Amorin

Copyright (C) 2005 David LaPorte

=head1 LICENSE

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
USA.

=cut

